/*
 * timer.c
 *
 *  Created on: 23 avr. 2020
 *      Author: marc
 */
#include"timer.h"
#include"game.h"

static timer timer_list;

void init_timer(void) {
	pthread_mutex_lock(&timer_list.mutex);
	for (int8_t i = 0; i < TIMER_NB; i++) {
		timer_list.timer[i].countdown = 0;
		timer_list.timer[i].owner = NO_OWNER;
		timer_list.timer[i].status = STOP;
		timer_list.timer[i].name = UNAFFECTED;
	}
	pthread_mutex_unlock(&timer_list.mutex);
}

int start_timer(timer_owner owner, int countdown) {
	int8_t activated_timer = 0;
	int8_t selected_timer = 0;
	pthread_mutex_lock(&timer_list.mutex);
	while (activated_timer == 0 && selected_timer != -1) {
		if (timer_list.timer[selected_timer].status == STOP) {
			timer_list.timer[selected_timer].countdown = countdown;
			timer_list.timer[selected_timer].owner = owner;
			timer_list.timer[selected_timer].status = ACTIVE;
			activated_timer = 1;
		} else {
			selected_timer++;
			if (selected_timer == TIMER_NB) {
				selected_timer = -1;
			}
		}
	}
	pthread_mutex_unlock(&timer_list.mutex);
	return selected_timer;
}

int stop_timer(timer_owner owner, timer_name name) {
	int8_t deactivated_timer = 0;
	int8_t selected_timer = 0;
	pthread_mutex_lock(&timer_list.mutex);
	while (deactivated_timer == 0) {
		if (timer_list.timer[selected_timer].status == ACTIVE
				&& timer_list.timer[selected_timer].owner == owner
				&& timer_list.timer[selected_timer].name == name) {
			timer_list.timer[selected_timer].countdown = 0;
			timer_list.timer[selected_timer].owner = NO_OWNER;
			timer_list.timer[selected_timer].name = UNAFFECTED;
			timer_list.timer[selected_timer].status = STOP;
			deactivated_timer = 1;
		} else {
			selected_timer++;
		}
		if (selected_timer == TIMER_NB) { //TIMER NON EXISTANT
			return 1;
		}
	}
	pthread_mutex_unlock(&timer_list.mutex);
	return 0;
}

/*****************************************************************************
 *
 *
 *                           THREAD
 *
 *
 ****************************************************************************/

void *timers(void *arg) {
	init_timer();
	data_msg message;
	pthread_mutex_init(&timer_list.mutex, NULL);
	while (1) {
		usleep(100000); // == 100 millisecondes
		pthread_mutex_lock(&timer_list.mutex);
		for (int8_t i = 0; i < TIMER_NB; i++) {
			if (timer_list.timer[i].status == ACTIVE) { // décrémente tous les timer actifs
				timer_list.timer[i].countdown--;
				if (timer_list.timer[i].countdown == 0) {
					QUEUE_ID queue =
							timer_list.timer[i].owner == APP ? QUEUE_READ :
							timer_list.timer[i].owner == DISPLAY ?
									QUEUE_SEND : 2; // identification du proprio du timer 2 == err
					message.timer.status = TIMEOUT;
					message.timer.name = timer_list.timer[i].name;
					printf("TIMER TIMEOUT : %d, %d\n", message.timer.status,
							message.timer.name);
					send_message(queue, &message, sizeof(message)); // envoi message timer timeout + nom
					// remise à zéro du timer
					timer_list.timer[i].countdown = 0;
					timer_list.timer[i].owner = NO_OWNER;
					timer_list.timer[i].status = STOP;
				}
			}
		}
		pthread_mutex_unlock(&timer_list.mutex);
	}
	return NULL;
}

